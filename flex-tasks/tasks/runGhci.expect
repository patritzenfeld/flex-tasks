#!/usr/bin/env expect

# GHC version to use
set ver [lindex $argv 0];
set timeout 3

log_user 0
spawn ghci-$ver Global TaskSettings TaskData Description Parse -Wall -Wno-orphans
log_user 1
expect_before timeout { exit 1 }

expect "ghci> "
send "import Control.Monad.Random (evalRandTIO)\r"
expect "ghci> "
send "import Data.Char (isLetter, isAscii)\r"
expect "ghci> "
send "import Data.Either (fromRight)\r"
expect "ghci> "
send "import Data.Text (pack)\r"
expect "ghci> "
send "import Data.List.Extra (headDef, isInfixOf, trim)\r"
expect "ghci> "
send "import Data.Map (member)\r"
expect "ghci> "
send "import FlexTask.ConvertForm (getFormData)\r"
expect "ghci> "
send "import FlexTask.InterpreterHelper ()\r"
expect "ghci> "
send "import Data.Tuple.Extra\r"
expect "ghci> "
send "import Data.Maybe\r"
expect "ghci> "
send "import Data.Generics.Text\r"
expect "ghci> "
send "import System.Directory (doesFileExist)\r"
expect "ghci> "
send "import Text.Parsec (parse)\r"
expect "ghci> "
send "import Control.Monad.Extra\r"
expect "ghci> "
send "import Control.Exception\r"
expect "ghci> "
send "import Control.Monad.Identity\r"
expect "ghci> "
send "import Control.OutputCapable.Blocks\r"
expect "ghci> "
send "import Control.OutputCapable.Blocks.Type\r"
expect "ghci> "
send "import Capabilities.Cache\r"
expect "ghci> "
send "import Capabilities.LatexSvg\r"
expect "ghci> "
send "import Capabilities.Graphviz\r"
expect "ghci> "
send "import Capabilities.Diagrams\r"
expect "ghci> "
send "import Capabilities.Alloy\r"
expect "ghci> "
send "import Capabilities.WriteFile\r"
expect "ghci> "
send "import Capabilities.Cache.IO\r"
expect "ghci> "
send "import Capabilities.LatexSvg.IO\r"
expect "ghci> "
send "import Capabilities.Graphviz.IO\r"
expect "ghci> "
send "import Capabilities.Diagrams.IO\r"
expect "ghci> "
send "import Capabilities.Alloy.IO\r"
expect "ghci> "
send "import Capabilities.WriteFile.IO\r"
expect "ghci> "
send "import FlexTask.Types (parseFlexConfig, validateFlexConfig)\r"
expect "ghci> "
send "configParse <- parse parseFlexConfig \"\" <\$> readFile \"config.txt\"\r"
expect "ghci> "
send "taskName <- trim <$> ifM (doesFileExist \"TaskName.txt\") (readFile \"TaskName.txt\") (pure \"\")\r"
expect "ghci> "
send "unless (all (liftA2 (&&) isLetter isAscii) taskName) \$ throw \$ AssertionFailed \$ \"The task name must consist only of ASCII letters: \" ++ taskName\r"
expect "ghci> "
send "(configRes,configOut) <- getOutputSequenceWithResult \$ validateFlexConfig \$ fromRight (throw \$ AssertionFailed \"Config could not be parsed\") configParse\r"
expect "ghci> "
send "when (isNothing configRes) \$ throw \$ AssertionFailed \$ \"Refusal in validateFlexConfig: \" ++ show configOut\r"
expect "ghci> "
send "getOutputSequence (TaskSettings.validateSettings :: LangM (ReportT Output Identity))\r"
expect "ghci> "
send "taskData <- evalRandTIO TaskData.getTask\r"
expect "ghci> "
send "let taskDataTypeTest = fst3 taskData :: TaskData\r"
expect "ghci> "
send "let taskDataString = gshow taskDataTypeTest\r"
expect "ghci> "
send "(fieldNames,localizedForm) <- getFormData (thd3 taskData)\r"
expect "ghci> "
send "when (null fieldNames) \$ throw \$ AssertionFailed \"The input form does not declare any field names!\"\r"
expect "ghci> "
send "unless (all (`member` localizedForm) \$ map pack \[\"de\",\"en\"\]) \$ throw \$ AssertionFailed \"The input form is missing a German or English translation!\"\r"
expect "ghci> "
send "writeFile \"Check.hs\" (snd3 taskData)\r"
expect "ghci> "
send "let greadError = fst . headDef (error \$ \"Could not read task data: \" ++ taskDataString) . gread\r"
expect "ghci> "
send "let descriptionTest = Description.description \"/tmp/flex-test\" (greadError taskDataString :: TaskData) :: (MonadCache m, MonadLatexSvg m, MonadGraphviz m, MonadDiagrams m, MonadAlloy m, MonadWriteFile m) => LangM (ReportT Output m)\r"
expect "ghci> "
send "(descRes,descOut) <- getOutputSequenceWithResult descriptionTest \r"
expect "ghci> "
send "descOut\r"
expect "ghci> "
send "when (isNothing descRes) \$ throw \$ AssertionFailed \$ \"Refusal in Description: \" ++ show descOut\r"
expect "ghci> "
send "parseContents <- readFile \"Parse.hs\"\r"
expect "ghci> "
send "let parseSubmissionTest = Parse.parseSubmission \"\" :: (MonadCache m, MonadLatexSvg m, MonadGraphviz m, MonadDiagrams m, MonadAlloy m, MonadWriteFile m) => LangM' (ReportT Output m) Submission\r"
expect "ghci> "
send "(result,parseOut) <- if \"parseInfallibly\" `isInfixOf` parseContents then pure (Nothing,\[\]) else getOutputSequenceWithResult parseSubmissionTest\r"
expect "ghci> "
send "parseOut\r"
expect "ghci> "
send "when (isJust result) \$ throw \$ AssertionFailed \$ \"Parsing did not abort on empty String: \" ++ show parseOut\r"
expect "ghci> "
send ":l Check.hs\r"
expect "\[1 of*Ok, two modules loaded.\r\n"
expect "ghci> "
send "let syntaxCheckTest = Check.checkSyntax \"\" (undefined :: TaskData) (undefined :: Submission) :: (MonadCache m, MonadLatexSvg m, MonadGraphviz m, MonadDiagrams m, MonadAlloy m, MonadWriteFile m) => LangM (ReportT Output m)\r"
expect "ghci> "
send "let semanticsCheckTest = Check.checkSemantics \"\" (undefined :: TaskData) (undefined :: Submission) :: (MonadCache m, MonadLatexSvg m, MonadGraphviz m, MonadDiagrams m, MonadAlloy m, MonadWriteFile m) => Rated (ReportT Output m)\r"
expect "ghci> "
send ":q\r"
expect "Leaving GHCi.\r\n"

