{-# language OverloadedStrings #-}
{-# language QuasiQuotes #-}
{-# language RecordWildCards #-}
{-# language TypeOperators #-}

{- | Functions for creating and composing forms.
-}

module FlexTask.FormUtil
  (
  -- * Functions for Rendered
    ($$>)
  , addCss
  , addJs
  , addCssAndJs
  , applyToWidget
  , getFormData
  -- * Convenience functions for Yesod FieldSettings
  , addAttribute
  , addAttributes
  , addCssClass
  , addNameAndCssClass
  , readOnly
  -- * Convenience for internationalization
  , universalLabel
  , showToUniversalLabel
  -- * functions for custom forms
  , newFlexId
  , newFlexName
  , repeatFlexName
  -- * debugging
  , printWidget
  ) where



import Control.Monad.Reader            (runReader)
import Data.Containers.ListUtils       (nubOrd)
import Data.IORef                      (readIORef, writeIORef)
import Data.List.Extra                 (isInfixOf, isPrefixOf, trimEnd, splitOn)
import Data.String                     (fromString)
import Data.Text                       (Text, pack)
import Data.Tuple.Extra                (second)
import System.Log.FastLogger           (defaultBufSize, newStdoutLoggerSet)
import Text.Blaze.Html.Renderer.String (renderHtml)
import Text.Cassius                    (Css)
import Text.Julius                     (Javascript)
import Yesod
import Yesod.Core.Types                (HandlerData(..), HandlerFor(..), RY, ghsIdent)
import Yesod.Default.Config2           (makeYesodLogger)

import qualified Control.Monad.Trans.RWS as RWS   (get)
import qualified Data.Map                as M     (lookup, fromList)
import qualified Data.Text               as T     (replace)
import qualified Yesod.Core.Unsafe       as Unsafe

import FlexTask.Types                  (HtmlDict)
import FlexTask.Processing.Text        (supportedLanguages)
import FlexTask.YesodConfig (
  FlexForm(..),
  Handler,
  Rendered,
  Rendered',
  Widget,
  )



{- $setup
>>> :set -XOverloadedStrings
>>> :set -XQuasiQuotes
>>> :set -XTypeApplications
>>> import FlexTask.Generic.Form
>>> let myForm = formify (Nothing @Int) [[single "input"]]
>>> let myOtherForm = formify (Nothing @String) [[single "input2"]]
-}


{- |
Compose two forms sequentially.
The result contains all fields from both input forms.
This is used to compose `FlexTask.Generic.Form.formify` generated forms with custom ones.

Note that forms generated by `FlexTask.Generic.Form.formify` will always be wrapped in an outer \<div\> tag.
This means composing such a form with something else results in a line break.
You may circumvent this via CSS rules on the 'flex-form-div' class.

=== __Example__

>>> printWidget "de" $ myForm $$> myOtherForm
<div class="flex-form-div">
...
    <label for="flexident1">
      ...
    </label>
...
</div>
<div class="flex-form-div">
...
    <label for="flexident2">
      ...
    </label>
...
</div>
-}
infixr 0 $$>
($$>)
  :: (Monad w, Monad m)
  => Rendered' m (w a)
  -> Rendered' m (w b)
  -> Rendered' m (w b)
f1 $$> f2 = do
    res1 <- f1
    res2 <- f2
    pure $ do
      (names1,wid1) <- res1
      (names2,wid2) <- res2
      pure (nubOrd $ names1 ++ names2, wid1 >> wid2)


{- |
Apply some function to the embedded `Widget` of a `Rendered` value.
This can be used to alter the form HTML after using `FlexTask.Generic.Form.formify`,
e.g. if some custom text is to be included with the element.

==== __Example__

>>> printWidget "de" $ applyToWidget ([whamlet| <h1>Insert me at once!|] >>) myForm
<h1>
  Insert me at once!
</h1>
<div class="flex-form-div">
...
</div>
-}
applyToWidget :: Functor m => (w -> w') -> Rendered' m w -> Rendered' m w'
applyToWidget f form = fmap (second f) <$> form


addContent
  :: (ToWidget FlexForm (render -> a), Functor m)
  => (render -> a)
  -> Rendered' m Widget
  -> Rendered' m Widget
addContent content = applyToWidget (<* toWidget content)


{- |
Add CSS to a form.
Use with `Yesod` Cassius or Lucius Shakespeare quasi quoters.
The content will be inserted in a \<style\> tag at the top of the document.

==== __Example__

>>> printWidget "en" $ addCss [lucius| myClass {margin: 2px}|] myForm
<style>
  myClass{margin:2px}
</style>
<div class="flex-form-div">
...
</div>
-}
addCss
  :: (render ~ RY FlexForm, Functor m)
  => (render -> Css)      -- ^ CSS template
  -> Rendered' m Widget -- ^ Form to add to
  -> Rendered' m Widget
addCss = addContent


{- |
Add JavaScript to a form.
Use with `Yesod` Julius Shakespeare quasi quoters.
The content will be inserted in a \<script\> tag at the bottom of the document.

==== __Example__

>>> printWidget "de" $ addJs [julius|myFunc(){ console.log("Hi"); }|] myForm
<div class="flex-form-div">
...
</div>
<script>
  myFunc(){ console.log("Hi"); }
</script>
-}
addJs
  :: (render ~ RY FlexForm, Functor m)
  => (render -> Javascript) -- ^ Javascript template
  -> Rendered' m Widget -- ^ Form to add to
  -> Rendered' m Widget
addJs = addContent


{- |
Like `addCss` and `addJs`, but for including CSS and JavaScript in one step.
-}
addCssAndJs
  :: (render ~ RY FlexForm, Functor m)
  => (render -> Css)        -- ^ CSS template
  -> (render -> Javascript) -- ^ Javascript template
  -> Rendered' m Widget -- ^ Form to add to
  -> Rendered' m Widget
addCssAndJs css js = applyToWidget ((<* toWidget css) . (<* toWidget js))


{- |
Directly create a Yesod FieldSettings with this name and CSS Class.

Using the `IsString` instance of `FieldSettings a` only sets the label.
The name is then auto generated.
Useful when writing a custom form to group multiple inputs.

==== __Example__

>>> addNameAndCssClass "testSettings" "nav" :: FieldSettings FlexForm
FieldSettings {..., fsName = Just "testSettings", fsAttrs = [("class","nav")]}
-}
addNameAndCssClass :: Text -> Text -> FieldSettings app
addNameAndCssClass name cssClass = addFieldAttrs
  where
    fSettings = fieldSettingsLabel name
    addFieldAttrs = fSettings {
      fsName = Just name,
      fsAttrs = addClass cssClass $ fsAttrs fSettings
      }


{- |
Add an attribute-value pair to the given FieldSettings.

==== __Example__

>>> addAttribute ("type","hidden") "testSettings" :: FieldSettings FlexForm
FieldSettings {fsLabel = (German: "testSettings", English: "testSettings"), ..., fsAttrs = [("type","hidden")]}
-}
addAttribute :: (Text,Text) -> FieldSettings app -> FieldSettings app
addAttribute attribute fs =  fs { fsAttrs = attribute : fsAttrs fs}


-- | Add a list of attribute-value pairs to the given FieldSettings.
addAttributes :: [(Text,Text)] -> FieldSettings app -> FieldSettings app
addAttributes as fs =  fs { fsAttrs = as ++ fsAttrs fs}


{- |
Add a CSS class to the given FieldSettings.

==== __Example__

>>> addCssClass "nav" "testSettings" :: FieldSettings FlexForm
FieldSettings {fsLabel = (German: "testSettings", English: "testSettings"), ..., fsAttrs = [("class","nav")]}
-}
addCssClass :: Text -> FieldSettings app -> FieldSettings app
addCssClass c fs = fs { fsAttrs = addClass c $ fsAttrs fs}


-- | Turn FieldSettings into a read-only input field.
readOnly :: FieldSettings app -> FieldSettings app
readOnly = addAttributes [("readonly",""),("style","background-color: #EEEEEE")]


{- |
Turn a String into a label for all languages.

==== __Example__

>>> universalLabel "index"
(German: "index", English: "index")
-}
universalLabel :: String -> SomeMessage FlexForm
universalLabel = fromString


{- |
Turn the Show instance of a value into a label for all languages.

==== __Example__

>>> showToUniversalLabel (1 :: Int)
(German: "1", English: "1")
-}
showToUniversalLabel :: Show a => a -> SomeMessage FlexForm
showToUniversalLabel = universalLabel . show


{- |
Get a unique identifier for an html element.
The format is "flexident[number]"
-}
newFlexId :: MForm Handler Text
newFlexId = T.replace "h" "flex" <$> newIdent


-- | repeat the last received name.
repeatFlexName :: MForm Handler Text
repeatFlexName = do
  i <- RWS.get
  pure $ pack $ "flex" ++ show i


{- |
Get a unique name for an html element.
The format is "flex[number]"
-}
newFlexName :: MForm Handler Text
newFlexName = T.replace "f" "flex" <$> newFormIdent


-- reset internal id generator to have same ids in all languages
resetIdentGen :: Handler ()
resetIdentGen = do
    x <- HandlerFor $ readIORef . handlerState
    HandlerFor $ flip writeIORef x {ghsIdent = 0} . handlerState


{- |
Extract a form from the environment.
The result is an IO embedded tuple of field IDs and a map of language and internationalized html pairs.
-}
getFormData :: Rendered Widget -> IO ([Text], HtmlDict)
getFormData widget = do
    logger <- newStdoutLoggerSet defaultBufSize >>= makeYesodLogger
    Unsafe.fakeHandlerGetLogger
      appLogger
      FlexForm {appLogger = logger}
      writeHtml
  where
    writeHtml :: Handler ([Text], HtmlDict)
    writeHtml = case supportedLanguages of
      (l:ls) -> do
        (names,first) <- withLang l
        rest <- traverse (fmap snd . withLang) ls
        return (names, M.fromList $ first:rest)
      _ -> error "No supported languages found!"

    withLang :: Lang -> Handler ([Text], (Lang, String))
    withLang lang = setRequestLang lang $ do
      resetIdentGen
      (names,wid) <- fst <$> runFormGet (runReader widget)
      content <- widgetToPageContent wid
      html <- withUrlRenderer [hamlet|
        ^{pageHead content}
        ^{pageBody content}|]
      return (names, (lang, concat $ lines $ renderHtml html))



-- Manipulate the request data to use a specific language.
setRequestLang :: Lang -> HandlerFor FlexForm a -> HandlerFor FlexForm a
setRequestLang lang HandlerFor{..} = do
  HandlerFor $ unHandlerFor . alterHandlerData
  where
    alterHandlerData hd@HandlerData{..} =
      hd{handlerRequest = handlerRequest{reqLangs = [lang]}}



{- |
Pretty prints the given embedded Widget's HTML code in the console.
Applies the specified language for internationalization.
Used for debugging.

=== __Example__

>>> printWidget "en" $ formify (Nothing @Int) [[single "Number Please"]]
<div class="flex-form-div">
  <input type="hidden" name="_hasdata">
  <span class="required flex-form-span">
    <label for="flexident1">
      Number Please
    </label>
    <input id="flexident1" name="flex1" type="number" step="1" required="" value="">
  </span>
</div>
-}
printWidget :: Lang -> Rendered Widget -> IO ()
printWidget lang render  = do
  (_, dict) <- getFormData render
  putStrLn $ maybe "Form not available in this language."
    (trimEnd . unlines . addIndent 0 . intoLines)
    $ M.lookup lang dict
  where
    intoLines s =
      let opening = map ("<" ++) $ drop 1 (splitOn "<" s)
          closing = concatMap (filter (/="") . splitOn ">") opening
      in  map (\x -> if "<" `isPrefixOf` x then x ++ ">" else x) closing

    addIndent _ [] = []
    addIndent i (s:ss)
      | "</" `isInfixOf` s
      = (replicate (i-2) ' ' ++ s) : addIndent (i-2) ss
      | ">" `isInfixOf` s && not (any (`isInfixOf` s) noClose)
      = (replicate i ' ' ++ s) : addIndent (i+2) ss
      | otherwise
      = (replicate i ' ' ++ s) : addIndent i ss

    noClose =
      [ "area"
      , "base"
      , "br"
      , "col"
      , "embed"
      , "hr"
      , "img"
      , "input"
      , "link"
      , "meta"
      , "param"
      , "source"
      , "track"
      , "wbr"
      ]
